{
  "version": 3,
  "sources": ["../../@mysten/utils/src/b58.ts", "../../@mysten/utils/src/b64.ts", "../../@mysten/utils/src/hex.ts", "../../@mysten/utils/src/chunk.ts", "../../@mysten/utils/src/with-resolver.ts", "../../@mysten/utils/src/dataloader.ts", "../../@mysten/bcs/src/uleb.ts", "../../@mysten/bcs/src/reader.ts", "../../@mysten/bcs/src/utils.ts", "../../@mysten/bcs/src/writer.ts", "../../@mysten/bcs/src/bcs-type.ts", "../../@mysten/bcs/src/bcs.ts", "../../valibot/dist/index.mjs", "../../@mysten/sui/src/utils/suins.ts", "../../@mysten/sui/src/utils/move-registry.ts", "../../@mysten/sui/src/utils/sui-types.ts", "../../@mysten/sui/src/transactions/data/internal.ts", "../../@mysten/sui/src/transactions/Commands.ts", "../../@mysten/sui/src/transactions/Inputs.ts", "../../@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/sui/src/bcs/bcs.ts", "../../@mysten/sui/src/bcs/effects.ts", "../../@mysten/sui/src/bcs/pure.ts", "../../@mysten/sui/src/bcs/index.ts", "../../@mysten/sui/src/utils/constants.ts", "../../@mysten/sui/src/utils/dynamic-fields.ts", "../../@mysten/sui/src/transactions/serializer.ts", "../../@mysten/sui/src/transactions/utils.ts", "../../@mysten/sui/src/transactions/data/v1.ts", "../../@mysten/sui/src/transactions/hash.ts", "../../@mysten/sui/src/transactions/TransactionData.ts", "../../@mysten/sui/src/experimental/cache.ts", "../../@mysten/sui/src/version.ts", "../../@mysten/sui/src/experimental/mvr.ts", "../../@mysten/sui/src/transactions/plugins/NamedPackagesPlugin.ts", "../../@mysten/sui/src/transactions/data/v2.ts", "../../@mysten/sui/src/jsonRpc/json-rpc-resolver.ts", "../../@mysten/sui/src/transactions/resolve.ts", "../../@mysten/sui/src/transactions/object.ts", "../../@mysten/sui/src/transactions/pure.ts", "../../@mysten/sui/src/transactions/Transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base58 } from '@scure/base';\n\nexport const toBase58 = (buffer: Uint8Array) => base58.encode(buffer);\nexport const fromBase58 = (str: string) => base58.decode(str) as Uint8Array<ArrayBuffer>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array<ArrayBuffer> {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array<ArrayBuffer> {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n\tconst intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\tif (intArr.length !== padded.length / 2) {\n\t\tthrow new Error(`Invalid hex string ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function chunk<T>(array: readonly T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(array.length / size) }, (_, i) => {\n\t\treturn array.slice(i * size, (i + 1) * size);\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface PromiseWithResolvers<T> {\n\tpromise: Promise<T>;\n\tresolve: (value: T) => void;\n\treject: (error: unknown) => void;\n}\n\nexport function promiseWithResolvers<T>(): PromiseWithResolvers<T> {\n\tlet resolver!: (value: T) => void;\n\tlet rejecter!: (error: unknown) => void;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tresolver = resolve;\n\t\trejecter = reject;\n\t});\n\n\treturn {\n\t\tpromise,\n\t\tresolve: resolver,\n\t\treject: rejecter,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Copied from https://github.com/graphql/dataloader/blob/a10773043d41a56bde4219c155fcf5633e6c9bcb/src/index.js */\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nexport class DataLoader<K, V, C = K> {\n\tconstructor(batchLoadFn: DataLoader.BatchLoadFn<K, V>, options?: DataLoader.Options<K, V, C>) {\n\t\tif (typeof batchLoadFn !== 'function') {\n\t\t\tthrow new TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t`Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`,\n\t\t\t);\n\t\t}\n\t\tthis._batchLoadFn = batchLoadFn;\n\t\tthis._maxBatchSize = getValidMaxBatchSize(options);\n\t\tthis._batchScheduleFn = getValidBatchScheduleFn(options);\n\t\tthis._cacheKeyFn = getValidCacheKeyFn(options);\n\t\tthis._cacheMap = getValidCacheMap(options);\n\t\tthis._batch = null;\n\t\tthis.name = getValidName(options);\n\t}\n\n\t// Private\n\t_batchLoadFn: DataLoader.BatchLoadFn<K, V>;\n\t_maxBatchSize: number;\n\t_batchScheduleFn: (cb: () => void) => void;\n\t_cacheKeyFn: (key: K) => C;\n\t_cacheMap: DataLoader.CacheMap<C, Promise<V>> | null;\n\t_batch: Batch<K, V> | null;\n\n\t/**\n\t * Loads a key, returning a `Promise` for the value represented by that key.\n\t */\n\tload(key: K): Promise<V> {\n\t\tif (key === null || key === undefined) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.load() function must be called with a value, but got: ${String(key)}.`,\n\t\t\t);\n\t\t}\n\n\t\tconst batch = getCurrentBatch(this);\n\t\tconst cacheMap = this._cacheMap;\n\t\tlet cacheKey: C;\n\n\t\t// If caching and there is a cache-hit, return cached Promise.\n\t\tif (cacheMap) {\n\t\t\tcacheKey = this._cacheKeyFn(key);\n\t\t\tconst cachedPromise = cacheMap.get(cacheKey);\n\t\t\tif (cachedPromise) {\n\t\t\t\tconst cacheHits = batch.cacheHits || (batch.cacheHits = []);\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tcacheHits.push(() => {\n\t\t\t\t\t\tresolve(cachedPromise);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise, produce a new Promise for this key, and enqueue it to be\n\t\t// dispatched along with the current batch.\n\t\tbatch.keys.push(key);\n\t\tconst promise = new Promise<V>((resolve, reject) => {\n\t\t\tbatch.callbacks.push({ resolve, reject });\n\t\t});\n\n\t\t// If caching, cache this promise.\n\t\tif (cacheMap) {\n\t\t\tcacheMap.set(cacheKey!, promise);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Loads multiple keys, promising an array of values:\n\t *\n\t *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n\t *\n\t * This is similar to the more verbose:\n\t *\n\t *     var [ a, b ] = await Promise.all([\n\t *       myLoader.load('a'),\n\t *       myLoader.load('b')\n\t *     ]);\n\t *\n\t * However it is different in the case where any load fails. Where\n\t * Promise.all() would reject, loadMany() always resolves, however each result\n\t * is either a value or an Error instance.\n\t *\n\t *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n\t *     // c instanceof Error\n\t *\n\t */\n\tloadMany(keys: ReadonlyArray<K>): Promise<Array<V | Error>> {\n\t\tif (!isArrayLike(keys)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`,\n\t\t\t);\n\t\t}\n\t\t// Support ArrayLike by using only minimal property access\n\t\tconst loadPromises = [];\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tloadPromises.push(this.load(keys[i]).catch((error) => error));\n\t\t}\n\t\treturn Promise.all(loadPromises);\n\t}\n\n\t/**\n\t * Clears the value at `key` from the cache, if it exists. Returns itself for\n\t * method chaining.\n\t */\n\tclear(key: K): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\t\t\tcacheMap.delete(cacheKey);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears the entire cache. To be used when some event results in unknown\n\t * invalidations across this particular `DataLoader`. Returns itself for\n\t * method chaining.\n\t */\n\tclearAll(): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tcacheMap.clear();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds the provided key and value to the cache. If the key already\n\t * exists, no change is made. Returns itself for method chaining.\n\t *\n\t * To prime the cache with an error at a key, provide an Error instance.\n\t */\n\tprime(key: K, value: V | Promise<V> | Error): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\n\t\t\t// Only add the key if it does not already exist.\n\t\t\tif (cacheMap.get(cacheKey) === undefined) {\n\t\t\t\t// Cache a rejected promise if the value is an Error, in order to match\n\t\t\t\t// the behavior of load(key).\n\t\t\t\tlet promise;\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tpromise = Promise.reject(value);\n\t\t\t\t\t// Since this is a case where an Error is intentionally being primed\n\t\t\t\t\t// for a given key, we want to disable unhandled promise rejection.\n\t\t\t\t\tpromise.catch(() => {});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve(value);\n\t\t\t\t}\n\t\t\t\tcacheMap.set(cacheKey, promise);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t *\n\t * Is `null` if not set in the constructor.\n\t */\n\tname: string | null;\n}\n\n// Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\nconst enqueuePostPromiseJob: (fn: () => void) => void =\n\t/** @ts-ignore */\n\ttypeof process === 'object' && typeof process.nextTick === 'function'\n\t\t? function (fn) {\n\t\t\t\tif (!resolvedPromise) {\n\t\t\t\t\tresolvedPromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\tresolvedPromise.then(() => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tprocess.nextTick(fn);\n\t\t\t\t});\n\t\t\t}\n\t\t: // @ts-ignore\n\t\t\ttypeof setImmediate === 'function'\n\t\t\t? function (fn) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tsetImmediate(fn);\n\t\t\t\t}\n\t\t\t: function (fn) {\n\t\t\t\t\tsetTimeout(fn);\n\t\t\t\t};\n\n// Private: cached resolved Promise instance\nlet resolvedPromise: Promise<void> | undefined;\n\n// Private: Describes a batch of requests\ntype Batch<K, V> = {\n\thasDispatched: boolean;\n\tkeys: Array<K>;\n\tcallbacks: Array<{\n\t\tresolve: (value: V) => void;\n\t\treject: (error: Error) => void;\n\t}>;\n\tcacheHits?: Array<() => void>;\n};\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch<K, V>(loader: DataLoader<K, V, any>): Batch<K, V> {\n\t// If there is an existing batch which has not yet dispatched and is within\n\t// the limit of the batch size, then return it.\n\tconst existingBatch = loader._batch;\n\tif (\n\t\texistingBatch !== null &&\n\t\t!existingBatch.hasDispatched &&\n\t\texistingBatch.keys.length < loader._maxBatchSize\n\t) {\n\t\treturn existingBatch;\n\t}\n\n\t// Otherwise, create a new batch for this loader.\n\tconst newBatch = { hasDispatched: false, keys: [], callbacks: [] };\n\n\t// Store it on the loader so it may be reused.\n\tloader._batch = newBatch;\n\n\t// Then schedule a task to dispatch this batch of requests.\n\tloader._batchScheduleFn(() => {\n\t\tdispatchBatch(loader, newBatch);\n\t});\n\n\treturn newBatch;\n}\n\nfunction dispatchBatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>) {\n\t// Mark this batch as having been dispatched.\n\tbatch.hasDispatched = true;\n\n\t// If there's nothing to load, resolve any cache hits and return early.\n\tif (batch.keys.length === 0) {\n\t\tresolveCacheHits(batch);\n\t\treturn;\n\t}\n\n\t// Call the provided batchLoadFn for this loader with the batch's keys and\n\t// with the loader as the `this` context.\n\tlet batchPromise;\n\ttry {\n\t\tbatchPromise = loader._batchLoadFn(batch.keys);\n\t} catch (e) {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function ' +\n\t\t\t\t\t`errored synchronously: ${String(e)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Assert the expected response from batchLoadFn\n\tif (!batchPromise || typeof batchPromise.then !== 'function') {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t`not return a Promise: ${String(batchPromise)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Await the resolution of the call to batchLoadFn.\n\tPromise.resolve(batchPromise)\n\t\t.then((values) => {\n\t\t\t// Assert the expected resolution from batchLoadFn.\n\t\t\tif (!isArrayLike(values)) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t`not return a Promise of an Array: ${String(values)}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (values.length !== batch.keys.length) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t'not return a Promise of an Array of the same length as the Array ' +\n\t\t\t\t\t\t'of keys.' +\n\t\t\t\t\t\t`\\n\\nKeys:\\n${String(batch.keys)}` +\n\t\t\t\t\t\t`\\n\\nValues:\\n${String(values)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Resolve all cache hits in the same micro-task as freshly loaded values.\n\t\t\tresolveCacheHits(batch);\n\n\t\t\t// Step through values, resolving or rejecting each Promise in the batch.\n\t\t\tfor (let i = 0; i < batch.callbacks.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tbatch.callbacks[i].reject(value);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.callbacks[i].resolve(value);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t.catch((error: unknown) => {\n\t\t\tfailedDispatch(loader, batch, error as Error);\n\t\t});\n}\n\n// Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\nfunction failedDispatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>, error: Error) {\n\t// Cache hits are resolved, even though the batch failed.\n\tresolveCacheHits(batch);\n\tfor (let i = 0; i < batch.keys.length; i++) {\n\t\tloader.clear(batch.keys[i]);\n\t\tbatch.callbacks[i].reject(error);\n\t}\n}\n\n// Private: Resolves the Promises for any cache hits in this batch.\nfunction resolveCacheHits(batch: Batch<any, any>) {\n\tif (batch.cacheHits) {\n\t\tfor (let i = 0; i < batch.cacheHits.length; i++) {\n\t\t\tbatch.cacheHits[i]();\n\t\t}\n\t}\n}\n\n// Private: given the DataLoader's options, produce a valid max batch size.\nfunction getValidMaxBatchSize<K, V, C>(options?: DataLoader.Options<K, V, C>): number {\n\tconst shouldBatch = !options || options.batch !== false;\n\tif (!shouldBatch) {\n\t\treturn 1;\n\t}\n\tconst maxBatchSize = options && options.maxBatchSize;\n\tif (maxBatchSize === undefined) {\n\t\treturn Infinity;\n\t}\n\tif (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n\t\tthrow new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);\n\t}\n\treturn maxBatchSize;\n}\n\n// Private\nfunction getValidBatchScheduleFn<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): (cb: () => void) => void {\n\tconst batchScheduleFn = options && options.batchScheduleFn;\n\tif (batchScheduleFn === undefined) {\n\t\treturn enqueuePostPromiseJob;\n\t}\n\tif (typeof batchScheduleFn !== 'function') {\n\t\tthrow new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);\n\t}\n\treturn batchScheduleFn;\n}\n\n// Private: given the DataLoader's options, produce a cache key function.\nfunction getValidCacheKeyFn<K, V, C>(options?: DataLoader.Options<K, V, C>): (key: K) => C {\n\tconst cacheKeyFn = options && options.cacheKeyFn;\n\tif (cacheKeyFn === undefined) {\n\t\treturn (key: K) => key as unknown as C;\n\t}\n\tif (typeof cacheKeyFn !== 'function') {\n\t\tthrow new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);\n\t}\n\treturn cacheKeyFn;\n}\n\n// Private: given the DataLoader's options, produce a CacheMap to be used.\nfunction getValidCacheMap<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): DataLoader.CacheMap<C, Promise<V>> | null {\n\tconst shouldCache = !options || options.cache !== false;\n\tif (!shouldCache) {\n\t\treturn null;\n\t}\n\tconst cacheMap = options && options.cacheMap;\n\tif (cacheMap === undefined) {\n\t\treturn new Map();\n\t}\n\tif (cacheMap !== null) {\n\t\tconst cacheFunctions = ['get', 'set', 'delete', 'clear'] as const;\n\t\tconst missingFunctions = cacheFunctions.filter(\n\t\t\t(fnName) => cacheMap && typeof cacheMap[fnName] !== 'function',\n\t\t);\n\t\tif (missingFunctions.length !== 0) {\n\t\t\tthrow new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n\t\t}\n\t}\n\treturn cacheMap;\n}\n\nfunction getValidName<K, V, C>(options?: DataLoader.Options<K, V, C>): string | null {\n\tif (options && options.name) {\n\t\treturn options.name;\n\t}\n\n\treturn null;\n}\n\nfunction isArrayLike(x: unknown): x is ArrayLike<unknown> {\n\treturn (\n\t\ttypeof x === 'object' &&\n\t\tx !== null &&\n\t\t'length' in x &&\n\t\ttypeof x.length === 'number' &&\n\t\t(x.length === 0 || (x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1)))\n\t);\n}\n\nexport declare namespace DataLoader {\n\t// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\texport type CacheMap<K, V> = {\n\t\tget(key: K): V | void;\n\t\tset(key: K, value: V): any;\n\t\tdelete(key: K): any;\n\t\tclear(): any;\n\t};\n\n\t// A Function, which when given an Array of keys, returns a Promise of an Array\n\t// of values or Errors.\n\texport type BatchLoadFn<K, V> = (keys: ReadonlyArray<K>) => PromiseLike<ArrayLike<V | Error>>;\n\n\t// Optionally turn off batching or caching or provide a cache key function or a\n\t// custom cache instance.\n\texport type Options<K, V, C = K> = {\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable batching, invoking\n\t\t * `batchLoadFn` with a single load key. This is equivalent to setting\n\t\t * `maxBatchSize` to `1`.\n\t\t */\n\t\tbatch?: boolean;\n\n\t\t/**\n\t\t * Default `Infinity`. Limits the number of items that get passed in to the\n\t\t * `batchLoadFn`. May be set to `1` to disable batching.\n\t\t */\n\t\tmaxBatchSize?: number;\n\n\t\t/**\n\t\t * Default see https://github.com/graphql/dataloader#batch-scheduling.\n\t\t * A function to schedule the later execution of a batch. The function is\n\t\t * expected to call the provided callback in the immediate future.\n\t\t */\n\t\tbatchScheduleFn?: (callback: () => void) => void;\n\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable memoization caching, creating a\n\t\t * new Promise and new key in the `batchLoadFn` for every load of the same\n\t\t * key. This is equivalent to setting `cacheMap` to `null`.\n\t\t */\n\t\tcache?: boolean;\n\n\t\t/**\n\t\t * Default `key => key`. Produces cache key for a given load key. Useful\n\t\t * when keys are objects and two objects should be considered equivalent.\n\t\t */\n\t\tcacheKeyFn?: (key: K) => C;\n\n\t\t/**\n\t\t * Default `new Map()`. Instance of `Map` (or an object with a similar API)\n\t\t * to be used as cache. May be set to `null` to disable caching.\n\t\t */\n\t\tcacheMap?: CacheMap<C, Promise<V>> | null;\n\n\t\t/**\n\t\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t\t *\n\t\t * Is `null` if not set in the constructor.\n\t\t */\n\t\tname?: string | null;\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number | bigint): number[] {\n\tlet bigNum = BigInt(num);\n\tconst arr: number[] = [];\n\tlet len = 0;\n\n\tif (bigNum === 0n) {\n\t\treturn [0];\n\t}\n\n\twhile (bigNum > 0) {\n\t\tarr[len] = Number(bigNum & 0x7fn);\n\t\tbigNum >>= 7n;\n\t\tif (bigNum > 0n) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0n;\n\tlet shift = 0n;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tif (len >= arr.length) {\n\t\t\tthrow new Error('ULEB decode error: buffer overflow');\n\t\t}\n\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal += BigInt(byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7n;\n\t}\n\n\t// TODO: return bigint in next major version\n\tif (total > BigInt(Number.MAX_SAFE_INTEGER)) {\n\t\tthrow new Error('ULEB decode error: value exceeds MAX_SAFE_INTEGER');\n\t}\n\n\treturn {\n\t\tvalue: Number(total),\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @returns {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @returns {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView<ArrayBuffer>;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(\n\t\t\t\tthis.maxSize,\n\t\t\t\tMath.max(this.size + requiredSize, this.size + this.allocateSize),\n\t\t\t);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteBytes(bytes: Uint8Array): this {\n\t\tthis.ensureSizeOrGrow(bytes.length);\n\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\tthis.dataView.setUint8(this.bytePosition + i, bytes[i]);\n\t\t}\n\n\t\treturn this.shift(bytes.length);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t// oxlint-disable-next-line require-yields\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array<ArrayBuffer>;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(schema: BcsType<T, Input>, bytes: Uint8Array<ArrayBuffer>) {\n\t\tthis.#schema = schema;\n\t\tthis.#bytes = bytes;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t}>,\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${options.name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${options.name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<T extends readonly BcsType<any>[], Name extends string>\n\textends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends\n\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsEnum,\n\tBcsStruct,\n\tBcsTuple,\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type {\n\tEnumInputShape,\n\tEnumOutputShape,\n\tInferBcsInput,\n\tInferBcsType,\n\tJoinString,\n} from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nfunction fixedArray<T extends BcsType<any>, Name extends string = string>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction fixedArray<T, Input, Name extends string = string>(\n\tsize: number,\n\ttype: BcsType<T, Input>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, Name>,\n): BcsType<T[], Iterable<Input> & { length: number }, Name>;\nfunction fixedArray<T extends BcsType<any>, Name extends string = `${T['name']}[${number}]`>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst result: InferBcsType<T>[] = new Array(size);\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `${type.name}[${size}]`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t\tif (value.length !== size) {\n\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`>;\nfunction option<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n): BcsType<T | null, Input | null | undefined>;\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`> {\n\treturn bcs\n\t\t.enum(`Option<${type.name}>`, {\n\t\t\tNone: null,\n\t\t\tSome: type,\n\t\t})\n\t\t.transform({\n\t\t\tinput: (value: InferBcsInput<T> | null | undefined) => {\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn { None: true };\n\t\t\t\t}\n\n\t\t\t\treturn { Some: value };\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\treturn value.Some as InferBcsType<T>;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n}\n\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction vector<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>,\n): BcsType<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>;\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result: InferBcsType<T>[] = new Array(length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\twriter.writeULEB(value.length);\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `vector<${type.name}>`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n>;\nfunction map<K, V, InputK = K, InputV = V>(\n\tkeyType: BcsType<K, InputK>,\n\tvalueType: BcsType<V, InputV>,\n): BcsType<Map<K, V>, Map<InputK, InputV>, `Map<${string}, ${string}>`>;\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n> {\n\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\tinput: (value: Map<InferBcsInput<K>, InferBcsInput<V>>) => {\n\t\t\treturn [...value.entries()];\n\t\t},\n\t\toutput: (value) => {\n\t\t\tconst result = new Map<InferBcsType<K>, InferBcsType<V>>();\n\t\t\tfor (const [key, val] of value) {\n\t\t\t\tresult.set(key, val);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n}\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u8') as 'u8',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u16') as 'u16',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u32') as 'u32',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u64') as 'u64',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u128') as 'u128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u256') as 'u256',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType({\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'bool') as 'bool',\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType({\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'uleb128') as 'uleb128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>, `bytes[${T}]`>({\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeBytes(new Uint8Array(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? `bytes[${size}]`) as `bytes[${T}]`,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>, 'vector<u8>'>({\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\twriter.writeBytes(array);\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'vector<u8>') as 'vector<u8>',\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'string') as 'string',\n\t\t});\n\t},\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray,\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption,\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector,\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<\n\t\tconst T extends readonly BcsType<any, any>[],\n\t\tconst Name extends\n\t\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n\t>(\n\t\tfields: T,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t) {\n\t\treturn new BcsTuple<T, Name>({\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsStruct<T>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t\t}>,\n\t\t\t\tName\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsEnum<T, Name>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap,\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += ` ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n   at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidSuiNSName } from './suins.js';\n\n/** The pattern to find an optionally versioned name */\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\n/** The pattern for a valid version number */\nconst VERSION_REGEX = /^\\d+$/;\n/** The maximum size for an app */\nconst MAX_APP_SIZE = 64;\n/** The separator for the name */\nconst NAME_SEPARATOR = '/';\n\nexport const isValidNamedPackage = (name: string): boolean => {\n\tconst parts = name.split(NAME_SEPARATOR);\n\t// The name has to have 2 parts (without-version), or 3 parts (with version).\n\tif (parts.length < 2 || parts.length > 3) return false;\n\n\tconst [org, app, version] = parts; // split by {org} {app} {optional version}\n\n\t// If the version exists, it must be a number.\n\tif (version !== undefined && !VERSION_REGEX.test(version)) return false;\n\t// Check if the org is a valid SuiNS name.\n\tif (!isValidSuiNSName(org)) return false;\n\n\t// Check if the app is a valid name.\n\treturn NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\n\n/**\n * Checks if a type contains valid named packages.\n * This DOES NOT check if the type is a valid Move type.\n */\nexport const isValidNamedType = (type: string): boolean => {\n\t// split our type by all possible type delimeters.\n\tconst splitType = type.split(/::|<|>|,/);\n\tfor (const t of splitType) {\n\t\tif (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n\t}\n\t// TODO: Add `isValidStructTag` check once it's introduced.\n\treturn true;\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport type { Simplify } from '@mysten/utils';\n\ntype EnumSchemaInput<T extends Record<string, GenericSchema<any>>> = EnumInputShape<\n\tSimplify<{\n\t\t[K in keyof T]: InferInput<T[K]>;\n\t}>\n>;\n\ntype EnumSchemaOutput<T extends Record<string, GenericSchema<any>>> = EnumOutputShape<\n\tSimplify<{\n\t\t[K in keyof T]: InferOutput<T[K]>;\n\t}>\n>;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumSchemaInput<T>,\n\tEnumSchemaOutput<T>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform(\n\t\t\t(value) =>\n\t\t\t\t({\n\t\t\t\t\t...value,\n\t\t\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t\t\t}) as EnumSchemaOutput<T>,\n\t\t),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRefSchema = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRefSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const ArgumentSchema = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof ArgumentSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasDataSchema = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\nexport type GasData = InferOutput<typeof GasDataSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTagSchema = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTagSchema>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBodySchema: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignatureSchema = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBodySchema,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignatureSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCallSchema = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(ArgumentSchema),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCallSchema>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const CommandSchema = safeEnum({\n\tMoveCall: ProgrammableMoveCallSchema,\n\tTransferObjects: object({\n\t\tobjects: array(ArgumentSchema),\n\t\taddress: ArgumentSchema,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: ArgumentSchema,\n\t\tamounts: array(ArgumentSchema),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: ArgumentSchema,\n\t\tsources: array(ArgumentSchema),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(ArgumentSchema),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: ArgumentSchema,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArgSchema = safeEnum({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArgSchema = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArgSchema>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionDataSchema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasDataSchema,\n\tinputs: array(CallArgSchema),\n\tcommands: array(CommandSchema),\n});\n\nexport type TransactionData = InferOutput<typeof TransactionDataSchema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { AsyncTransactionThunk, Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof ArgumentSchema>\n\t| ((tx: Transaction) => InferInput<typeof ArgumentSchema>)\n\t| AsyncTransactionThunk;\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof ArgumentSchema>[],\n\t\taddress: InferInput<typeof ArgumentSchema>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(ArgumentSchema, o)),\n\t\t\t\taddress: parse(ArgumentSchema, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof ArgumentSchema>,\n\t\tamounts: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(ArgumentSchema, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof ArgumentSchema>,\n\t\tsources: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(ArgumentSchema, destination),\n\t\t\t\tsources: sources.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof ArgumentSchema>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(ArgumentSchema, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof ArgumentSchema>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<\n\t\t\tstring,\n\t\t\tInferInput<typeof ArgumentSchema> | InferInput<typeof ArgumentSchema>[]\n\t\t>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value)\n\t\t\t\t\t\t\t? value.map((o) => parse(ArgumentSchema, o))\n\t\t\t\t\t\t\t: parse(ArgumentSchema, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n\nexport function normalizeTypeTag(type: string): string {\n\treturn TypeTagSerializer.tagToString(TypeTagSerializer.parseFromStr(type));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.byteVector().transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.byteVector().transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.bytes(64),\n\tSecp256k1: bcs.bytes(64),\n\tSecp256r1: bcs.bytes(64),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.byteVector(),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.bytes(32),\n\tSecp256k1: bcs.bytes(33),\n\tSecp256r1: bcs.bytes(33),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.bytes(33),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.byteVector().transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.byteVector(),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.byteVector(),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.byteVector() }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\t// TODO: these have been renamed to MutateConsensusStreamEnded and ReadConsensusStreamEnded\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = {\n\terror: `Invalid Pure type name: ${T}`;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = (name as string).match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, BcsStruct, BcsEnum, BcsTuple, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionEffects,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\nexport const SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId('0x8');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport type { TypeTag } from '../bcs/bcs.js';\nimport { bcs } from '../bcs/index.js';\n\nexport function deriveDynamicFieldID(\n\tparentId: string,\n\ttypeTag: typeof TypeTag.$inferInput,\n\tkey: Uint8Array,\n) {\n\tconst address = bcs.Address.serialize(parentId).toBytes();\n\tconst tag = bcs.TypeTag.serialize(typeTag).toBytes();\n\tconst keyLength = bcs.u64().serialize(key.length).toBytes();\n\n\tconst hash = blake2b.create({\n\t\tdkLen: 32,\n\t});\n\n\thash.update(new Uint8Array([0xf0]));\n\thash.update(address);\n\thash.update(keyLength);\n\thash.update(key);\n\thash.update(tag);\n\n\treturn `0x${toHex(hash.digest().slice(0, 32))}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(ArgumentSchema, value);\n}\n\nexport function remapCommandArguments(\n\tcommand: Command,\n\tinputMapping: Map<number, number>,\n\tcommandMapping: Map<number, number>,\n) {\n\tconst remapArg = (arg: Argument): Argument => {\n\t\tswitch (arg.$kind) {\n\t\t\tcase 'Input': {\n\t\t\t\tconst newInputIndex = inputMapping.get(arg.Input);\n\t\t\t\tif (newInputIndex === undefined) {\n\t\t\t\t\tthrow new Error(`Input ${arg.Input} not found in input mapping`);\n\t\t\t\t}\n\t\t\t\treturn { ...arg, Input: newInputIndex };\n\t\t\t}\n\t\t\tcase 'Result': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.Result);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, Result: newCommandIndex };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tcase 'NestedResult': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.NestedResult[0]);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, NestedResult: [newCommandIndex, arg.NestedResult[1]] };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn arg;\n\t\t}\n\t};\n\n\tswitch (command.$kind) {\n\t\tcase 'MoveCall':\n\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'TransferObjects':\n\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);\n\t\t\tcommand.TransferObjects.address = remapArg(command.TransferObjects.address);\n\t\t\tbreak;\n\t\tcase 'SplitCoins':\n\t\t\tcommand.SplitCoins.coin = remapArg(command.SplitCoins.coin);\n\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MergeCoins':\n\t\t\tcommand.MergeCoins.destination = remapArg(command.MergeCoins.destination);\n\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MakeMoveVec':\n\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'Upgrade':\n\t\t\tcommand.Upgrade.ticket = remapArg(command.Upgrade.ticket);\n\t\t\tbreak;\n\t\tcase '$Intent': {\n\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'Publish':\n\t\t\tbreak;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from './internal.js';\nimport type { Argument, ArgumentSchema, TransactionData } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionDataSchema, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionDataSchema>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof ArgumentSchema> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n\tTransactionData,\n} from './data/internal.js';\nimport { ArgumentSchema, TransactionDataSchema } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\nimport { getIdFromCallArg, remapCommandArguments } from './utils.js';\nimport type { TransactionResult } from './Transaction.js';\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2Schema>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(\n\t\tindex: number,\n\t\treplacement: Command | Command[],\n\t\tresultIndex: number | { Result: number } | { NestedResult: [number, number] } = index,\n\t) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\n\t\tthis.commands.splice(index, 1, ...structuredClone(replacement));\n\n\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\treturn arg;\n\t\t\t}\n\n\t\t\tif (typeof resultIndex !== 'number') {\n\t\t\t\tif (\n\t\t\t\t\t(arg.$kind === 'Result' && arg.Result === index) ||\n\t\t\t\t\t(arg.$kind === 'NestedResult' && arg.NestedResult[0] === index)\n\t\t\t\t) {\n\t\t\t\t\tif (!('NestedResult' in arg) || arg.NestedResult[1] === 0) {\n\t\t\t\t\t\treturn parse(ArgumentSchema, structuredClone(resultIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle adjustment of other references\n\t\t\tswitch (arg.$kind) {\n\t\t\t\tcase 'Result':\n\t\t\t\t\tif (arg.Result === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NestedResult':\n\t\t\t\t\tif (arg.NestedResult[0] === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\t\t\tNestedResult: [resultIndex, arg.NestedResult[1]],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treplaceCommandWithTransaction(\n\t\tindex: number,\n\t\totherTransaction: TransactionData,\n\t\tresult: TransactionResult,\n\t) {\n\t\tif (result.$kind !== 'Result' && result.$kind !== 'NestedResult') {\n\t\t\tthrow new Error('Result must be of kind Result or NestedResult');\n\t\t}\n\n\t\tthis.insertTransaction(index, otherTransaction);\n\n\t\tthis.replaceCommand(\n\t\t\tindex + otherTransaction.commands.length,\n\t\t\t[],\n\t\t\t'Result' in result\n\t\t\t\t? { NestedResult: [result.Result + index, 0] }\n\t\t\t\t: {\n\t\t\t\t\t\tNestedResult: [\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[0] + index,\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[1],\n\t\t\t\t\t\t] as [number, number],\n\t\t\t\t\t},\n\t\t);\n\t}\n\n\tinsertTransaction(atCommandIndex: number, otherTransaction: TransactionData) {\n\t\tconst inputMapping = new Map<number, number>();\n\t\tconst commandMapping = new Map<number, number>();\n\n\t\tfor (let i = 0; i < otherTransaction.inputs.length; i++) {\n\t\t\tconst otherInput = otherTransaction.inputs[i];\n\t\t\tconst id = getIdFromCallArg(otherInput);\n\n\t\t\tlet existingIndex = -1;\n\t\t\tif (id !== undefined) {\n\t\t\t\texistingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);\n\n\t\t\t\tif (\n\t\t\t\t\texistingIndex !== -1 &&\n\t\t\t\t\tthis.inputs[existingIndex].Object?.SharedObject &&\n\t\t\t\t\totherInput.Object?.SharedObject\n\t\t\t\t) {\n\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable =\n\t\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable ||\n\t\t\t\t\t\totherInput.Object.SharedObject.mutable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingIndex !== -1) {\n\t\t\t\tinputMapping.set(i, existingIndex);\n\t\t\t} else {\n\t\t\t\tconst newIndex = this.inputs.length;\n\t\t\t\tthis.inputs.push(otherInput);\n\t\t\t\tinputMapping.set(i, newIndex);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tcommandMapping.set(i, atCommandIndex + i);\n\t\t}\n\n\t\tconst remappedCommands: Command[] = [];\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tconst command = structuredClone(otherTransaction.commands[i]);\n\n\t\t\tremapCommandArguments(command, inputMapping, commandMapping);\n\n\t\t\tremappedCommands.push(command);\n\t\t}\n\n\t\tthis.commands.splice(atCommandIndex, 0, ...remappedCommands);\n\n\t\tconst sizeDiff = remappedCommands.length;\n\t\tif (sizeDiff > 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (\n\t\t\t\t\tcommandIndex >= atCommandIndex &&\n\t\t\t\t\tcommandIndex < atCommandIndex + remappedCommands.length\n\t\t\t\t) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result >= atCommandIndex) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] >= atCommandIndex) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionDataSchema, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n\n\tapplyResolvedData(resolved: TransactionData) {\n\t\tif (!this.sender) {\n\t\t\tthis.sender = resolved.sender ?? null;\n\t\t}\n\n\t\tif (!this.expiration) {\n\t\t\tthis.expiration = resolved.expiration ?? null;\n\t\t}\n\n\t\tif (!this.gasData.budget) {\n\t\t\tthis.gasData.budget = resolved.gasData.budget;\n\t\t}\n\n\t\tif (!this.gasData.owner) {\n\t\t\tthis.gasData.owner = resolved.gasData.owner ?? null;\n\t\t}\n\n\t\tif (!this.gasData.payment) {\n\t\t\tthis.gasData.payment = resolved.gasData.payment;\n\t\t}\n\n\t\tif (!this.gasData.price) {\n\t\t\tthis.gasData.price = resolved.gasData.price;\n\t\t}\n\n\t\tfor (let i = 0; i < this.inputs.length; i++) {\n\t\t\tconst input = this.inputs[i];\n\t\t\tconst resolvedInput = resolved.inputs[i];\n\n\t\t\tswitch (input.$kind) {\n\t\t\t\tcase 'UnresolvedPure':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Pure') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UnresolvedObject':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Object') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'ImmOrOwnedObject' ||\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'Receiving'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved =\n\t\t\t\t\t\t\tresolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving!;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.version != null && original.version !== resolved.version) ||\n\t\t\t\t\t\t\t(original.digest != null && original.digest !== resolved.digest) ||\n\t\t\t\t\t\t\t// Objects with shared object properties should not resolve to owned objects\n\t\t\t\t\t\t\toriginal.mutable != null ||\n\t\t\t\t\t\t\toriginal.initialSharedVersion != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resolvedInput.Object.$kind === 'SharedObject') {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved = resolvedInput.Object.SharedObject;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.initialSharedVersion != null &&\n\t\t\t\t\t\t\t\toriginal.initialSharedVersion !== resolved.initialSharedVersion) ||\n\t\t\t\t\t\t\t(original.mutable != null && original.mutable !== resolved.mutable) ||\n\t\t\t\t\t\t\t// Objects with owned object properties should not resolve to shared objects\n\t\t\t\t\t\t\toriginal.version != null ||\n\t\t\t\t\t\t\toriginal.digest != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput.Object,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ClientCacheOptions {\n\tprefix?: string[];\n\tcache?: Map<string, unknown>;\n}\n\nexport class ClientCache {\n\t#prefix: string[];\n\t#cache: Map<string, unknown>;\n\n\tconstructor({ prefix, cache }: ClientCacheOptions = {}) {\n\t\tthis.#prefix = prefix ?? [];\n\t\tthis.#cache = cache ?? new Map();\n\t}\n\n\tread<T>(key: [string, ...string[]], load: () => T | Promise<T>): T | Promise<T> {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\tif (typeof result === 'object' && result !== null && 'then' in result) {\n\t\t\treturn Promise.resolve(result)\n\t\t\t\t.then((v) => {\n\t\t\t\t\tthis.#cache.set(cacheKey, v);\n\t\t\t\t\treturn v as T;\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tthis.#cache.delete(cacheKey);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\treadSync<T>(key: [string, ...string[]], load: () => T): T {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\treturn result as T;\n\t}\n\n\tclear(prefix?: string[]) {\n\t\tconst prefixKey = [...this.#prefix, ...(prefix ?? [])].join(':');\n\t\tif (!prefixKey) {\n\t\t\tthis.#cache.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const key of this.#cache.keys()) {\n\t\t\tif (key.startsWith(prefixKey)) {\n\t\t\t\tthis.#cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tscope(prefix: string | string[]) {\n\t\treturn new ClientCache({\n\t\t\tprefix: [...this.#prefix, ...(Array.isArray(prefix) ? prefix : [prefix])],\n\t\t\tcache: this.#cache,\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.45.2';\nexport const TARGETED_RPC_VERSION = '1.62.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tif (!hasMvrName(name)) {\n\t\t\treturn {\n\t\t\t\tpackage: name,\n\t\t\t};\n\t\t}\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tif (!hasMvrName(type)) {\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '../../experimental/cache.js';\nimport { MvrClient } from '../../experimental/mvr.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport { findNamesInTransaction, replaceNames } from '../../experimental/mvr.js';\nimport type { NamedPackagesOverrides } from '../../experimental/mvr.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The URL of the MVR API to use for resolving names.\n\t */\n\turl: string;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * The type cache expects ONLY first-level types to ensure the cache is more composable.\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesOverrides;\n};\n\n// The original versions of the mvr plugin cached lookups by mutating overrides.\n// We don't want to mutate the options, but we can link our cache to the provided overrides object\n// This preserves the caching across transactions while removing the mutation side effects\nconst cacheMap = new WeakMap<object, ClientCache>();\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = (options?: NamedPackagesPluginOptions) => {\n\tlet mvrClient: MvrClient | undefined;\n\n\tif (options) {\n\t\tconst overrides = options.overrides ?? {\n\t\t\tpackages: {},\n\t\t\ttypes: {},\n\t\t};\n\n\t\tif (!cacheMap.has(overrides)) {\n\t\t\tcacheMap.set(overrides, new ClientCache());\n\t\t}\n\n\t\tmvrClient = new MvrClient({\n\t\t\tcache: cacheMap.get(overrides)!,\n\t\t\turl: options.url,\n\t\t\tpageSize: options.pageSize,\n\t\t\toverrides: overrides,\n\t\t});\n\t}\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\tbuildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findNamesInTransaction(transactionData);\n\n\t\tif (names.types.length === 0 && names.packages.length === 0) {\n\t\t\treturn next();\n\t\t}\n\n\t\tconst resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n\t\t\ttypes: names.types,\n\t\t\tpackages: names.packages,\n\t\t});\n\n\t\treplaceNames(transactionData, resolved);\n\n\t\tawait next();\n\t};\n};\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRefSchema, SuiAddress } from './internal.js';\nimport type { Simplify } from '@mysten/utils';\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tSimplify<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2Schema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n\tdigest: optional(nullable(string())),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2Schema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRefSchema } from '../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../transactions/data/internal.js';\nimport { Inputs } from '../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { BuildTransactionOptions } from '../transactions/index.js';\nimport type { SuiJsonRpcClient } from './client.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function jsonRpcClientResolveTransactionPlugin(client: SuiJsonRpcClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) =>\n\t\t\tparse(ObjectRefSchema, payment),\n\t\t);\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\tclient: SuiJsonRpcClient,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) =>\n\t\t\t\t\tinput?.UnresolvedPure ||\n\t\t\t\t\t(input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== 'boolean'),\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (\n\t\t\ttx.$kind === 'MakeMoveVec' ||\n\t\t\ttx.$kind === 'MergeCoins' ||\n\t\t\ttx.$kind === 'SplitCoins' ||\n\t\t\ttx.$kind === 'TransferObjects'\n\t\t) {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { jsonRpcClientResolveTransactionPlugin } from '../jsonRpc/json-rpc-resolver.js';\nimport type { SuiJsonRpcClient } from '../jsonRpc/client.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tjsonRpcClientResolveTransactionPlugin(client as SuiJsonRpcClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\nimport { Inputs } from './Inputs.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = (options?: { mutable?: boolean }) => {\n\t\tconst mutable = options?.mutable;\n\n\t\tif (mutable !== undefined) {\n\t\t\treturn object(\n\t\t\t\tInputs.SharedObjectRef({\n\t\t\t\t\tobjectId: '0x5',\n\t\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\t\tmutable,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x5',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t},\n\t\t});\n\t};\n\tobject.clock = () =>\n\t\tobject(\n\t\t\tInputs.SharedObjectRef({\n\t\t\t\tobjectId: '0x6',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\tmutable: false,\n\t\t\t}),\n\t\t);\n\tobject.random = () =>\n\t\tobject({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x8',\n\t\t\t\tmutable: false,\n\t\t\t},\n\t\t});\n\tobject.denyList = (options?: { mutable?: boolean }) => {\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x403',\n\t\t\t\tmutable: options?.mutable,\n\t\t\t},\n\t\t});\n\t};\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command, Argument, ObjectRef } from './data/internal.js';\nimport {\n\tArgumentSchema,\n\tNormalizedCallArg,\n\tObjectRefSchema,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\nimport type { ClientWithCoreApi } from '../experimental/core.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>\n\t| ((\n\t\t\ttx: Transaction,\n\t  ) => Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is TransactionLike {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\ntype TransactionLike = {\n\tgetData(): unknown;\n};\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | TransactionLike) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(\n\t\t\t\ttransaction.getData() as InferInput<typeof SerializedTransactionDataV2Schema>,\n\t\t\t);\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(ArgumentSchema, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(ArgumentSchema, resolved);\n\t\t}\n\n\t\treturn parse(ArgumentSchema, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2Schema,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: ClientWithCoreApi;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\ttry {\n\t\t\tconst createNext = (i: number) => {\n\t\t\t\tif (i >= plugins.length) {\n\t\t\t\t\treturn () => {};\n\t\t\t\t}\n\t\t\t\tconst plugin = plugins[i];\n\n\t\t\t\treturn async () => {\n\t\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\t\tlet calledNext = false;\n\t\t\t\t\tlet nextResolved = false;\n\n\t\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\t\tawait next();\n\n\t\t\t\t\t\tnextResolved = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextResolved) {\n\t\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tawait createNext(0)();\n\t\t} finally {\n\t\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\t\tthis.#commandSection = this.#data.commands.slice();\n\t\t\tthis.#availableResults = new Set(this.#commandSection.map((_, i) => i));\n\t\t}\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["base64String", "chunk", "array", "cacheMap", "vector", "bigint", "_BcsType", "options", "validate", "name", "array", "option", "UpgradePolicy", "TransactionExpiration", "TransactionExpiration", "ObjectArg", "NormalizedCallArg", "TransactionExpiration", "TypeTag", "StructTag", "resolved", "_ClientCache", "__privateAdd", "__privateSet", "__privateGet", "_cache", "NAME_SEPARATOR", "__privateAdd", "__privateSet", "__privateGet", "Argument", "GasData", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "chunk", "object", "inputs", "getClient", "object", "_Transaction", "__privateAdd", "__privateGet", "__privateMethod", "__privateSet", "result", "_a"]
}
